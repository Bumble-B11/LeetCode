# LeetCode138
#### 题目描述
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的深拷贝。 
#### 输入、输出示例
Example 1:
> Input: {"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

> Output: {"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

#### 解题思路

首先遍历一遍原链表，遍历的过程中对每一个节点做深拷贝，并保存next的节点关系
然后对拷贝的链表的random域赋值。假设当前节点为N'，与之对应的原链表中的节点为N。N的random域
指向S，则N'的random域应该指向S'。
现在的问题在于如何确定拷贝链表中的S'的位置。

解法一：
最笨的办法就是在原链表中遍历，直到找到S，记录下当前指针移动的次数。然后遍历拷贝链表同样的次数。
此时指向的节点就是S'
这种方法的时间复杂度是O(n*n)

解法二：
在第一次遍历原链表保存next关系时，使用map保存原链表每个节点和拷贝链表每个节点的映射。比如(N, N')、(S, S')
第二次遍历原链表，通过原链表中的N在map中取出N'，如果N有random S，在map中通过S取出对应的S'，这样就找到S'了

这种时间复杂度是O(n), 由于需要额外的map来保存映射关系，空间复杂度也是O(n)

解法三：
不使用map来保存映射关系，在第一次遍历原链表时，将深拷贝出来的节点插入到原链表中，形成如下链表：
A -> A' -> B -> B' -> C -> C' -> NULL
第二次遍历链表，给A'的random赋值时，通过A取得其random域S，则S的下一个就是S'。
第三次遍历链表，将插入的深拷贝节点从原链表中取出即可。
