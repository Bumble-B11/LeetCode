# No233
#### 题目描述
给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
#### 输入、输出示例

Example 2:
> Input: 13

> Output: 6

原因：小于等于13的数字中带有1的：1, 10, 11, 12, 13

Example 2:
> Input: 1410065408

> Output: 1737167499

#### 解题思路
解法1
最简单的，遍历小于等于n的每一个数字，每遍历一个数字时，循环查看其每一位是否为1。
while(n > 0) {
    sum += n % 10 == 1 ? 1 : 0;
    n /= 10;
}
这种思路简单，但是时间复杂度太高

解法2
归纳每一位上1出现的次数的规律。
##### 个位
n的大小：       9, 10, 15, 25, 160, 165, 1600, 1655
出现次数：      1,  1,  1,  3,  16,  17,  160,  161
可以总结出一个规律，每满一个10，就会有一个个位上的1。那像165这样的数字呢，它满了16个10并且还有剩余。这时就需要考察n % 10是否为0。只要不为0，个位上1的个数就需要加一。
举两个例子：  
160，满了16个10，但是160 % 10 == 0，所以最终它拥有16个个位上的1。
165，满了16个10，但是165 % 10 != 0，所以最终它拥有17个个位上的1。(多了一个161)

总结：个位上数字为1的个数 = n / 10 + (n % 10 == 0 ? 0 : 1);
##### 十位
n的大小：       9, 10, 15, 20, 50, 100, 165, 1600, 1655
出现次数：      1,  1,  6, 10, 10,  10,  20,  160,  170

可以总结出规律：每满1个100，就会有10个十位上的1。像100有10个十位1。像165这样的呢，满了100还剩x，这是需要看x - 10的结果。
1. 如果x - 10小于0，则这部分有0个十位上的1
2. 如果x - 10大于等于0，则这部分最多有Max(x - 10 + 1, 10)个十位上的1

总结: 十位上数字为1的个数 = n / 100 + min(max(n - 10 + 1, 0), 10);

##### 百位
n的大小：       100, 105, 180, 200, 587, 1000, 1650, 16000, 16550
出现次数：       1,    6,  81, 100, 100,  100,  200,  1600,  1610

可以总结出规律：每满1个1000，就会有100个百位上的1。像1000有100个百位1。像1650这样的呢，满了100还剩x，这是需要看x - 100的结果。
1. 如果x - 100小于0，则这部分有0个百位上的1
2. 如果x - 10大于等于0，则这部分最多有Max(x - 100 + 1, 100)个百位上的1

可以看出，百位上的1和十位上的1规律十分明显了。对于非个位上的1，可以总结出如下公式：
digit为位数，比如十位为2，百位为3，千位为4...
int full = Math.pow(10, digit);
x位上数字为1的个数 = (n / full * (full / 10)) + min(max(n - (full / 10) + 1, 0), full / 10);

根据以上公式，可以获得除个位以外任意一位上的1的个数，循环计算每一位然后相加即可。

这里有需要注意的几点:
1. 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。但是这里并没有说n是否为非负整数，所以要对这种特殊情况做处理
2. 这里给定义的方法返回值为int型，说明这里计算的数字范围在十亿级别之内。但是我们在计算full时需要对当前的位数做10次方运算，比如十位的full是100， 百位的full是1000
那十亿位的full就变成一百亿了，这里要考虑用long型存储full避免溢出的问题。